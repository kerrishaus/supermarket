<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>let's go shoppin</title>
		<style>
	        *
			{
			    pointer-events: none;
			    user-select: none;
			}
		
			html, body
			{
			    margin: 0;
			    background-color: black;
                overflow-x: hidden;
                
                height: 100%;
                width: 100%;
                
                overflow-x: hidden;
                overflow-y: hidden;
            }
            
            body
            {
                position: relative;
            }
		</style>
		
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		
		<script src="https://kerrishaus.com/assets/scripts/jquery-3.6.0.min.js"></script>
		<script src="https://portal.kerrishaus.com/assets/javascript/messages.js"></script>
		<link rel='stylesheet' href='https://portal.kerrishaus.com/assets/styles/messages.css'>
	</head>
	<body>
	    <div style='position: absolute; top: 0px; left: 0px; width: 100vw; height: 100vh; overflow-x: hidden; overflow-y: hidden; pointer-events: none'>
	        <div id='money' style='color: white;background-color: #222;border: 3px solid white; padding: 4px;'>
	            fuck
	        </div>
	        
	        <div id='moving' style='color: white;background-color: #222;border: 3px solid white; padding: 4px;'>
	            no
	        </div>
	        
	        <div id='mouse' style='color: white;background-color: #222;border: 3px solid white; padding: 4px;'>
	            no
	        </div>
	    </div>
	    
		<script type='module'>
		    import * as THREE from "https://kerrishaus.com/assets/threejs/build/three.module.js";
		    import { CSS2DObject, CSS2DRenderer } from "https://kerrishaus.com/assets/threejs/examples/jsm/renderers/CSS2DRenderer.js";
		    import { TransformControls } from 'https://kerrishaus.com/assets/threejs/examples/jsm/controls/TransformControls.js';

		    function createCube(color)
		    {
		        const geometry = new THREE.BoxGeometry(1, 1, 1);
		        const material = new THREE.MeshBasicMaterial({ color: color });
		        
		        return new THREE.Mesh(geometry, material);
		    }
		    
		    function createScaledCube(width, height, thickness, color)
		    {
		        const geometry = new THREE.BoxGeometry(width, height, thickness);
		        const material = new THREE.MeshBasicMaterial({ color: color });
		        
		        return new THREE.Mesh(geometry, material);
		    }
		    
		    class DynamicMesh extends THREE.Mesh
		    {
		        constructor(geometry, material)
		        {
		            super(geometry, material);
		        }
		        
		        update()
		        {
		            
		        }
		    };
		    
		    class Interactable extends DynamicMesh
		    {
		        constructor(width, length, triggerWidth, triggerLength, color)
		        {
		            const geometry = new THREE.BoxGeometry(width, length, 1);
		            const material = new THREE.MeshBasicMaterial({ color: color });
		            
		            super(geometry, material);
		            
		            const triggerGeometry = new THREE.BoxGeometry(triggerWidth, triggerLength, 0.1);
		            const triggerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2 });
		            
		            this.triggerObject = new THREE.Mesh(triggerGeometry, triggerMaterial);
		            this.triggerObject.geometry.computeBoundingBox();
		            this.attach(this.triggerObject);
		            this.triggerObject.position.z -= 0.4;
		            
		            this.trigger = new THREE.Box3();
		            
		            this.triggered = false;
		            this.triggeringObject = null;
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            this.trigger.copy(this.triggerObject.geometry.boundingBox).applyMatrix4(this.triggerObject.matrixWorld);
		        }
		        
		        onTrigger(object)
		        {
		            this.triggered = true;
		            this.triggeringObject = object;
		            
		            this.triggerObject.material.color.setHex(0x00ff00);
		        }
		        
		        onStopTrigger(object)
		        {
		            if (!this.triggered)
		                return;
		                
	                this.triggered = false;
	                this.triggeringObject = null;
	                
	                this.triggerObject.material.color.setHex(0xff0000);
		        }
		    };
		    
		    class Carryable extends DynamicMesh
		    {
		        constructor(width, height, thickness, color)
		        {
		            const geometry = new THREE.BoxGeometry(width, height, thickness);
		            const material = new THREE.MeshBasicMaterial({color: color});
		            
		            super(geometry, material);
		            
		            this.offset         = new THREE.Vector3(0, 0, 0);
		            this.owner          = new THREE.Vector3(0, 0, 0);
		            this.targetPosition = new THREE.Vector3(0, 0, 0);
		            this.startPosition  = new THREE.Vector3(0, 0, 0);
		            
		            this.elapsedTime = 0;
		            this.moveTime = 0.4;
		        }
		        
		        setTarget(owner, offset)
		        {
		            this.startPosition.copy(this.position);
		            this.updateTarget(owner, offset);
		            this.elapsedTime = 0;
		        }
		        
		        updateTarget(owner, offset)
		        {
		            if (!(owner instanceof THREE.Vector3))
		            {
		                console.error("owner not instance of Vector3", owner);
		                return
		            }
		            
		            if (!(offset instanceof THREE.Vector3))
		            {
		                console.error("offset not instance of Vector3", offset);
		                return
		            }
		            
		            this.owner.copy(owner);
		            this.offset.copy(offset);
		            
		            this.targetPosition = new THREE.Vector3(this.owner.x + this.offset.x,
	                                                        this.owner.y + this.offset.y,
		                                                    this.owner.z + this.offset.z);
		        }
		        
		        update(deltaTime)
		        {
		            if (this.elapsedTime > this.moveTime)
		                return;
		            
                    this.elapsedTime += deltaTime;
                    this.position.lerpVectors(this.startPosition, this.targetPosition, this.elapsedTime / this.moveTime);
		        }
		    };
		    
		    class RecycleBin extends Interactable
		    {
		        constructor(xPos, yPos)
		        {
		            super(1, 1, 2, 2, 0x00ff00);
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
		            this.timeSinceLastRecycle = 0;
		            this.recycleInterval = 0.3;
		            
		            this.carriedItems = new Array();
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            this.timeSinceLastRecycle += deltaTime;
		            
		            for (const item of this.carriedItems)
		                if (item.elapsedTime > item.moveTime)
		                {
		                    this.carriedItems.splice(this.carriedItems.indexOf(item), 1);
		                    scene.remove(item);
		                }
		        }
		        
		        recycleItem(holder)
		        {
		            if (holder.carriedItems.length <= 0)
		                return;
		                
                    const item = holder.carriedItems[holder.carriedItems.length - 1]
                    holder.carriedItems.splice(holder.carriedItems.indexOf(holder), 1);
                    this.carriedItems.push(item);
                    item.setTarget(this.position, new THREE.Vector3(0, 0, 0));
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
	                    if (this.timeSinceLastRecycle > this.recycleInterval)   
                        {
                            this.recycleItem(player);
                            this.timeSinceLastRecycle = 0;
                        }
	                    
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    }
		    
		    class BuyableTile extends Interactable
		    {
		        constructor(width, length, xPos, yPos, price, name)
		        {
		            super(width, length, width + 3, length + 3, 0xff0000);
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
                    const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'buyableTileTitle';
        			labelDiv.textContent = name;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
        			
        			this.carriedMoney = new Array();
        			
		            this.price = price;
		            this.pricePaid = 0;
		            
		            this.onFullyPaid = function() {};
		        }
		        
                transferMoney(player)
		        {
		            if (player.money <= 0)
		                return;
		                
		            const money = new Carryable(0.3, 0.2, 0.02, 0x48c942);
                    money.position.copy(this.position);
                    money.setTarget(this.position, new THREE.Vector3(0, 0, 0));
                    money.startPosition.copy(player.position);
                    scene.add(money);
                    
		            this.carriedMoney.push(money);
		            this.pricePaid += 1;
		            player.money -= 1;
		            
		            if (this.pricePaid == this.price)
		            {
		                this.onFullyPaid();
		                return;
		            }
		            
		            this.label.element.textContent = this.price - this.pricePaid;
		            $("#money").html(player.money);
		        }
		        
		        update(deltaTime)
		        {
                    super.update();
                 
                    for (const money of this.carriedMoney)
                    {
                        if (money.elapsedTime > money.moveTime)
                        {
                            scene.remove(money);
                            this.carriedMoney.splice(this.carriedMoney.indexOf(money), 1);
                            continue;
                        }
                        
                        money.startPosition.copy(player.position);
                    }
		        }
		    };
		    
		    class Tomato extends Carryable
		    {
		        constructor(position)
		        {
		            super(0.4, 0.4, 0.4, 0x852520);
		            
		            this.position.copy(position);
		        }
		    };
		    
		    class TomatoPlant extends Interactable
		    {
		        constructor()
		        {
		            super(0.2, 0.2, 1, 1, 0xff0000);
		            
		            this.timeSinceLastGrowth = 0;
		            this.tomatoes = new Array();
		            
                    const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'unitCount';
        			labelDiv.textContent = this.tomatoes.length;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            if (this.tomatoes.length < 3)
    		            if (this.timeSinceLastGrowth > 3)
    		            {
    		                this.grow();
    		                this.timeSinceLastGrowth = 0;
    		            }
		            
		            this.timeSinceLastGrowth += deltaTime;
		        }
		        
		        grow()
		        {
		            const newTomato = new Tomato(this.position);
		            newTomato.setTarget(this.position, new THREE.Vector3(0, 1, 0));
		            this.tomatoes.push(newTomato);
		            scene.add(newTomato);
		            
		            this.label.element.textContent = this.tomatoes.length;
		        }
		        
		        transferTomato(receiver)
		        {
		            if (this.tomatoes.length <= 0)
		                return;
		                
		            const tomato = this.tomatoes[this.tomatoes.length - 1];
		            tomato.carryPos = receiver.carriedItems.length + 1;
		            tomato.moveTime = 0.17;
		            
		            // TODO: I want to set the offset vector here, in the future
		            // but right now it's really not required because it will set by
		            // updateTarget later in Player#update
		            tomato.setTarget(receiver.position, new THREE.Vector3(0, 0, 0));
		            
		            receiver.carriedItems.push(tomato);
		            
		            this.tomatoes.pop();
		            this.label.element.textContent = this.tomatoes.length;
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferTomato(object);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class TomatoStand extends Interactable
		    {
		        constructor(xPos, yPos)
		        {
		            super(1, 1, 2, 2, 0x4d220b);
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
		            this.carriedItems = new Array();
		            this.maxItems = 9;
		        }
		        
		        captureHeldTomato(holder)
		        {
		            if (this.carriedItems.length >= this.maxItems)
		                return;
		            
		            for (const item of holder.carriedItems)
		            {
		                if (item instanceof Tomato)
		                {
		                    holder.carriedItems.splice(holder.carriedItems.indexOf(item), 1);
		                    this.carriedItems.push(item);
		                    
		                    const rows = 3;
                            const columns = 3;
                            const totalPerStack = rows * columns;
		                    
                            let stacks = Math.floor(this.carriedItems.length / totalPerStack);
                            let currentStack = this.carriedItems.length - (stacks * totalPerStack);
                            let row = Math.floor(currentStack / rows);
                            let column = currentStack - (row * columns);
		                    
		                    item.setTarget(this.position, new THREE.Vector3(column - 1, row - 1, 1));
		                }
		            }
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.captureHeldTomato(player);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class Register extends Interactable
		    {
		        constructor()
		        {
		            super(2, 4, 4, 6, 0xad723e);
		            
        			this.money = new Array();
		            this.timeSinceLastMoney = 0;
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            if (this.timeSinceLastMoney >= 6)
		            {
		                this.addMoney();
		                this.timeSinceLastMoney = 0;
		            }
		            
		            this.timeSinceLastMoney += deltaTime
		        }
		        
		        addMoney()
		        {
                    const rows = 4;
                    const columns = 5;
                    const totalPerStack = rows * columns;
                    
                    let stacks = Math.floor(this.money.length / totalPerStack);
                    let currentStack = this.money.length - (stacks * totalPerStack);
                    let row = Math.floor(currentStack / rows);
                    let column = currentStack - (row * columns) + (1 * row)

                    const money = new Carryable(0.3, 0.2, 0.02, 0x48c942);
                    money.position.copy(this.position);
                    money.setTarget(this.position, new THREE.Vector3(column * 0.3, row * 0.2, 0.5 + (0.1 * stacks)));
                    
                    /*
                    money.position.x = column * 0.3;
                    money.position.y = row * 0.2;
                    money.position.z = 0.5 + (0.1 * stacks);
                    */
		            
		            scene.add(money);
		            this.money.push(money);
		        }
		        
		        transferMoney(player)
		        {
		            if (this.money.length <= 0)
		                return;
		                
		            const money = this.money[this.money.length - 1];
		            
		            //money.parent.remove(money);
                    //money.matrixWorld.decompose(money.position, money.quaternion, money.scale);
		            money.setTarget(player.position, new THREE.Vector3(0, 0, 0));
		            
		            player.carriedMoney.push(money);
		            
		            this.money.pop();
		            
		            player.money += 1;
		            $("#money").html(player.money);
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferMoney(object);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class Customer extends DynamicMesh
		    {
	            constructor(register, items)
                {
                    const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    const material = new THREE.MeshBasicMaterial({color: 0xaabbcc});
                    
                    super(geometry, material);
                    
                    this.register = register;
                    
                    this.timeElapsed = 0;
                    this.startPosition = null;
                    this.endPosition = null;
                    
                    return this;
                }
                
                destruct()
                {
                }
                
                setTarget(endPosition)
                {
                    this.timeElapsed = 0;
                    this.startPosition = this.object.position;
                    this.endPosition = endPosition;
                }
                
                update(deltaTime)
                {
                    if (this.timeElapsed > 0.7)
                    {
                        this.object.position.copy(this.endPosition);
                        
                        if (this.state == 0)
                        {
                            this.state = 2;
                            this.setHex(0x0000ff);
                        }
                        else if (this.state == 2 && this.linePosition == 0)
                        {
                            this.state = 3;
                            this.setHex(0x00ff00);
                        }
                    }
                    else
                    {
                        this.object.position.lerpVectors(this.startPosition, this.endPosition, this.timeElapsed / 3);
                        this.timeElapsed += deltaTime;
                    }
                }
		    };
		    
		    class Player extends DynamicMesh
		    {
		        constructor()
		        {
		            const geometry = new THREE.BoxGeometry(1, 1, 1);
		            const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
		            
		            super(geometry, material);
		            
		            this.rotationTarget = new THREE.Mesh(geometry, material);
		            
		            this.geometry.computeBoundingBox();
		            
		            this.box = new THREE.Box3();
		            
		            this.money = 0;
		            
		            this.carriedItems = new Array();
		            this.carriedMoney = new Array();
		        }
		        
		        update(deltaTime)
		        {
		            this.box.copy(this.geometry.boundingBox).applyMatrix4(this.matrixWorld);
		            
		            for (const item of this.carriedItems)
		            {
		                const carryPos = 1 + (item.scale.z * item.carryPos);
		                
		                if (item.elapsedTime > item.moveTime)
	                    {
	                        item.position.copy(this.position);
	                        item.position.z += carryPos;
	                        continue;
	                    }
	                    
	                    item.updateTarget(this.position, new THREE.Vector3(0, 0, carryPos));
		            }
		                
	                for (const money of this.carriedMoney)
	                {
	                    if (money.elapsedTime > money.moveTime)
	                    {
	                        scene.remove(money);
	                        this.carriedMoney.splice(this.carriedMoney.indexOf(money), 1);
	                        continue;
	                    }
	                    
	                    money.updateTarget(player.position, new THREE.Vector3(0, 0, 0));
	                }
	                
	                this.quaternion.slerp(this.rotationTarget.quaternion, 0.3);
	                this.quaternion.y = 0;
	                this.quaternion.x = 0;
		        }
		    };

			const scene = new THREE.Scene();

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const htmlRenderer = new CSS2DRenderer();
			htmlRenderer.setSize(window.innerWidth, window.innerHeight);
			htmlRenderer.domElement.style.position = 'absolute';
			htmlRenderer.domElement.style.top = '0px';
			document.body.appendChild(htmlRenderer.domElement).style.pointerEvents = "none";

			const shopFloor = createCube(0xe0e0e0);
			shopFloor.scale.x = 40;
			shopFloor.scale.y = 20;
			shopFloor.position.z = -1;
			scene.add(shopFloor);
			
			const shopNorthWall = createCube(0xe0e0e0);
			shopNorthWall.scale.x = 40;
			shopNorthWall.scale.y = 1;
			shopNorthWall.scale.z = 4;
			shopNorthWall.position.z = -1;
			scene.add(shopFloor);

			const farmFloor = createCube(0x41c92c);
			farmFloor.scale.x = 40;
			farmFloor.scale.y = 20;
			farmFloor.position.y = -20;
			farmFloor.position.z = -1;
			scene.add(farmFloor);

			const register = new Register();
			register.position.x = -16;
			register.position.y = 6;
			for (let i = 0; i < 400; i++)
                register.addMoney();
			scene.add(register);

			const recycleBin = new RecycleBin(6, 4);
			recycleBin.position.x = -4;
			recycleBin.position.y = 8;
			scene.add(recycleBin);

			const tomatoPlant1 = new TomatoPlant();
			tomatoPlant1.position.x = 3;
			scene.add(tomatoPlant1);

			let tomatoStandBuyTile = new BuyableTile(1, 1, 1, 4, 100, "Tomato Stand");
			tomatoStandBuyTile.onFullyPaid = function()
			{
			    console.log("i'm done!");
			    
			    scene.add(new TomatoStand(1, 4));
			    scene.remove(tomatoStandBuyTile.label);
			    scene.remove(tomatoStandBuyTile);
			    tomatoStandBuyTile = null;
			};
			scene.add(tomatoStandBuyTile);

            const player = new Player();
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(player);
            
            window.oncontextmenu = function(event) {
                 event.preventDefault();
                 event.stopPropagation();
                 return false;
            };
            
            $(document).resize((event) =>
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            });

            let keys = new Array();

            $(document).keydown(function(event)
            {
                keys[event.code] = true;
            });
            
            $(document).keyup(function(event)
            {
                keys[event.code] = false;
            });
            
            let moving = false;
            
            $(document).on('mousedown touchstart', (event) =>
            {
                moving = true;
                
                scene.add(moveTarget);
            });
            
            $(document).on('mouseup touchend', (event) =>
            {
                moving = false;
                
                scene.remove(moveTarget);
            });
            
            let geometry = new THREE.SphereGeometry(1, 12, 8);
            
            let material = new THREE.MeshPhongMaterial({
              color: 0x00ffff, 
              flatShading: true,
              transparent: true,
              opacity: 0.7,
            });
            
            let moveTarget = new THREE.Mesh(geometry, material);
            
            let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

            let mouse = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let intersects = new THREE.Vector3();
            
            $(document).on('mousemove', (event) =>
            {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            });
            
            $(document).on('touchmove', (event) =>
            {
                mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2 + 1;
                
                event.preventDefault();
            });
            
            const clock = new THREE.Clock();
            
            let customers = new Array();
            
            /*
            setInterval(function()
            {
                let customer = new Customer();
                customer.setRegister(register);
                customer.setTarget(register.position());
                customers.push(customer);
                scene.add(customer);
            }, 5000);
            */

			function animate()
			{
				requestAnimationFrame(animate);
				
				const deltaTime = clock.getDelta();
				
				if (!moving)
				{
    				if (keys["KeyW"])
    				    player.position.y += 0.15;
    			    if (keys["KeyA"])
    			        player.position.x -= 0.15;
    		        if (keys["KeyS"])
    				    player.position.y -= 0.15;
    				if (keys["KeyD"])
    				    player.position.x += 0.15;
			    }
			    else
			    {
    			    raycaster.setFromCamera(mouse, camera);
                    raycaster.ray.intersectPlane(plane, intersects);
                    moveTarget.position.set(intersects.x, intersects.y, intersects.z);
    			    
    			    player.rotationTarget.position.copy(player.position);
                    player.rotationTarget.lookAt(moveTarget.position);
    			    
    			    player.position.lerp(moveTarget.position, 0.03);
			    }
				
				camera.position.copy(player.position);
				camera.position.z = 10;
    			camera.position.y += -3
    			camera.lookAt(player.position);
    			
			    if (tomatoStandBuyTile !== null)
    			    if (player.box.intersectsBox(tomatoStandBuyTile.trigger))
    			        tomatoStandBuyTile.transferMoney(player);
			    
                scene.children.forEach( (object) =>
                {
                    if (object instanceof DynamicMesh)
                        object.update(deltaTime);
                        
                    if (object instanceof Interactable)
                        if (player.box.intersectsBox(object.trigger))
                            object.onTrigger(player);
                        else if (object.triggered)
                            object.onStopTrigger(player);
                });
                
				renderer.render(scene, camera);
				htmlRenderer.render(scene, camera);
			};
			
			/*
			if (document.webkitFullscreenElement) 
			{
                document.webkitCancelFullScreen();
            }
            else
            {
                const el = document.documentElement;
                el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
            */

			animate();
		</script>
	</body>
</html>
