<!DOCTYPE html>
<html>
	<head>
		<title>let's go shoppin</title>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		
		<link rel='stylesheet' href='./styles/game.css'>
		<link rel='stylesheet' href='./styles/interface.css'>
		
		<script src="https://kerrishaus.com/assets/scripts/jquery-3.6.0.min.js"></script>
		<script src="https://portal.kerrishaus.com/assets/javascript/messages.js"></script>
		<link rel='stylesheet' href='https://portal.kerrishaus.com/assets/styles/messages.css'>
	</head>
	<body>
	    
	    <div class='banner'>
	        <div>
	            $<span id='money'>0</span>
	        </div>
	        <div id='reputation'>
	            rep <span>0</span>
	        </div>
	    </div>
	    
	    <div class='buttons'>
	        <div class='upgrades'>
	            
	        </div>
	    </div>
	    
		<script type='module'>
			import * as Ammo from "https://kerrishaus.com/assets/ammojs/ammo.wasm.js";
		    import * as THREE from "https://kerrishaus.com/assets/threejs/build/three.module.js";
		    import { CSS2DObject, CSS2DRenderer } from "https://kerrishaus.com/assets/threejs/examples/jsm/renderers/CSS2DRenderer.js";
		    import { TransformControls } from 'https://kerrishaus.com/assets/threejs/examples/jsm/controls/TransformControls.js';
		    
			import * as GeometryUtil from "./scripts/GeometryUtility.js";

		    import { DynamicMesh } from "./scripts/DynamicMesh.js";
		    import { Interactable } from "./scripts/InteractableMesh.js";
			import { Carryable } from "./scripts/Carryable.js";
		    import { RecycleBin } from "./scripts/RecycleBin.js";
			import { Door } from "./scripts/Door.js";
		    import { Player } from "./scripts/Player.js";

		    class BuyableTile extends Interactable
		    {
		        constructor(width, length, xPos, yPos, price, name)
		        {
		            super(width, length, width + 3, length + 3, 0xff0000);
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
                    const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'buyableTileTitle';
        			labelDiv.textContent = name;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
        			
        			this.carriedMoney = new Array();
        			
		            this.price = price;
		            this.pricePaid = 0;
		            
		            this.onFullyPaid = function() {};
		        }
		        
                takeMoneyFrom(player)
		        {
		            if (player.money <= 0)
		                return;
		                
		            const money = new Carryable(0.3, 0.2, 0.02, 0x48c942);
                    money.position.copy(this.position);
                    money.setTarget(this.position, new THREE.Vector3(0, 0, 0));
                    money.startPosition.copy(player.position);
                    scene.add(money);
                    
		            this.carriedMoney.push(money);
		            this.pricePaid += 1;
		            player.money -= 1;
		            
		            if (this.pricePaid == this.price)
		            {
		                this.onFullyPaid();
		                return;
		            }
		            
		            this.label.element.textContent = this.price - this.pricePaid;
		            $("#money").html(player.money);
		        }
		        
		        update(deltaTime)
		        {
                    super.update();
                 
                    for (const money of this.carriedMoney)
                    {
                        if (money.elapsedTime > money.moveTime)
                        {
                            scene.remove(money);
                            this.carriedMoney.splice(this.carriedMoney.indexOf(money), 1);
                            continue;
                        }
                        
                        money.startPosition.copy(player.position);
                    }
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.takeMoneyFrom(object);
		        }
		    };
		    
		    class Tomato extends Carryable
		    {
		        constructor(position)
		        {
		            super(0.4, 0.4, 0.4, 0x852520);
		            
		            this.position.copy(position);
		        }
		    };
		    
		    class TomatoPlant extends Interactable
		    {
		        constructor()
		        {
		            super(0.2, 0.2, 1, 1, 0xff0000);
		            
		            this.name = "tomatoPlant";
		            
		            this.timeSinceLastGrowth = 0;
		            this.tomatoes = new Array();
		            
                    const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'unitCount';
        			labelDiv.textContent = this.tomatoes.length;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            if (this.tomatoes.length < 3)
    		            if (this.timeSinceLastGrowth > 3)
    		            {
    		                this.grow();
    		                this.timeSinceLastGrowth = 0;
    		            }
		            
		            this.timeSinceLastGrowth += deltaTime;
		        }
		        
		        grow()
		        {
		            const newTomato = new Tomato(this.position);
		            newTomato.setTarget(this.position, new THREE.Vector3(0, 1, 0));
		            this.tomatoes.push(newTomato);
		            scene.add(newTomato);
		            
		            this.label.element.textContent = this.tomatoes.length;
		        }
		        
		        transferTomato(receiver)
		        {
		            if (this.tomatoes.length <= 0)
		                return;
		                
		            const tomato = this.tomatoes[this.tomatoes.length - 1];
		            tomato.carryPos = receiver.carriedItems.length + 1;
		            tomato.moveTime = 0.17;
		            
		            // TODO: I want to set the offset vector here, in the future
		            // but right now it's really not required because it will set by
		            // updateTarget later in Player#update
		            tomato.setTarget(receiver.position, new THREE.Vector3(0, 0, 0));
		            tomato.autoPositionAfterAnimation = false;
		            
		            receiver.carriedItems.push(tomato);
		            
		            this.tomatoes.pop();
		            this.label.element.textContent = this.tomatoes.length;
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferTomato(object);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class TomatoStand extends Interactable
		    {
		        constructor(xPos, yPos)
		        {
		            super(1, 1, 2, 2, 0x4d220b);
		            
		            this.name = "tomatoStand";
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
		            this.carriedItems = new Array();
		            this.maxItems = 9;
		        }
		        
		        captureHeldTomato(holder)
		        {
		            if (this.carriedItems.length >= this.maxItems)
		                return;
		            
		            for (const item of holder.carriedItems)
		            {
		                if (item instanceof Tomato)
		                {
		                    holder.carriedItems.splice(holder.carriedItems.indexOf(item), 1);
		                    this.carriedItems.push(item);
		                    
		                    const rows = 3;
                            const columns = 3;
                            const totalPerStack = rows * columns;
		                    
                            let stacks = Math.floor(this.carriedItems.length / totalPerStack);
                            let currentStack = this.carriedItems.length - (stacks * totalPerStack);
                            let row = Math.floor(currentStack / rows);
                            let column = currentStack - (row * columns);
		                    
		                    item.setTarget(this.position, new THREE.Vector3(column - 1, row - 1, 1));
		                    item.autoPositionAfterAnimation = true;
		                }
		            }
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.captureHeldTomato(player);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };

		    class Register extends Interactable
		    {
		        constructor()
		        {
		            super(2, 4, 4, 6, 0xad723e);
		            
		            this.name = "register";
		            
        			this.money = new Array();
		            this.timeSinceLastMoney = 0;
		            
                    this.column_ = 0;
                    this.row_ = 0;
                    this.layer_ = 0;
                    
                    this.gridRows = 9;
                    this.gridColumns = 4;
		            
		            this.moneyLength = 0.3;
                    this.moneyWidth = 0.2;
                    this.moneyThickness = 0.2;
                    
                    this.moneyTexture = new THREE.TextureLoader().load('textures/dollar.jpeg');
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            if (this.timeSinceLastMoney >= 0.1)
		            {
		                this.addMoney();
		                this.timeSinceLastMoney = 0;
		            }
		            
		            this.timeSinceLastMoney += deltaTime
		        }
		        
		        addMoney()
                {
                    this.calculateGrid();
                    
                    const money = new Carryable(this.moneyLength, this.moneyWidth, this.moneyThickness, 0x48c942);
                    
    				const material = new THREE.MeshBasicMaterial({ map: this.moneyTexture });
    				money.material = material;
                    
                    money.position.copy(this.position);
                    money.setTarget(this.position, new THREE.Vector3(this.column_ * this.moneyLength - 0.4,
                                                                     this.row_ * this.moneyWidth,
                                                                     (this.scale.z / 2) + (this.layer_ * this.moneyThickness)));
                    
                    scene.add(money);
                    this.money.push(money);
		        }
		        
		        transferMoney(player)
		        {
		            if (this.money.length <= 0)
		                return;
		                
		            const money = this.money[this.money.length - 1];
		            
		            //money.parent.remove(money);
                    //money.matrixWorld.decompose(money.position, money.quaternion, money.scale);
		            money.setTarget(player.position, new THREE.Vector3(0, 0, 0));
		            
		            player.carriedMoney.push(money);
		            
		            this.money.pop();
		            
		            this.calculateGrid();
		            
		            player.money += 1;
		            $("#money").html(player.money);
		        }
		        
                calculateGrid()
                {
                    this.column_ = 0;
                    this.row_    = 0;
                    this.layer_  = 0;
                    
                    for (let i = 0; i < this.money.length; i++)
                    {
                        this.column_ += 1;
                        
                        if (this.column_ >= this.gridColumns)
                        {
                            this.column_ = 0;
                            this.row_ += 1;
                        }
                        
                        if (this.row_ >= this.gridRows)
                        {
                            this.row_ = 0;
                            this.layer_ += 1;
                        }
                    }
                }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferMoney(object);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class Shop extends DynamicMesh
		    {
		        constructor()
		        {
		            super();
		            
		            // shop floor
		            scene.add(GeometryUtil.createObject(new THREE.Vector3(40, 20, 1), new THREE.Vector3(0, 10, -1), 0xE0E0E0));
		            // shop north wall
		            scene.add(GeometryUtil.createObject(new THREE.Vector3(40, 1, 4), new THREE.Vector3(0, 19.5, 1.5), 0xbfbfbf));
		            // west wall
		            scene.add(GeometryUtil.createObject(new THREE.Vector3(1, 20, 4), new THREE.Vector3(-19.5, 10, 1.5), 0xbfbfbf));
		            // east wall
		            scene.add(GeometryUtil.createObject(new THREE.Vector3(1, 20, 4), new THREE.Vector3(19.5, 10, 1.5), 0xbfbfbf));
		            
		            this.doors = new Door(new THREE.Vector3(-9.5, 19.4, 0), 0x0000ff);
		            scene.add(this.doors);
		            
		            // farm floor
		            scene.add(GeometryUtil.createObject(new THREE.Vector3(40, 20, 1), new THREE.Vector3(0, -10, -1), 0x44CD32));
		            
		            this.register = new Register();
        			this.register.position.x = -16;
        			this.register.position.y = 15;
        			for (let i = 0; i < 100; i++)
                        this.register.addMoney();
		            scene.add(this.register);
		            
        			this.recycleBin = new RecycleBin(6, 4);
        			this.recycleBin.position.x = -4;
        			this.recycleBin.position.y = 17;
        			scene.add(this.recycleBin);
        			
					let tomatoStandBuyTile = new BuyableTile(1, 1, 1, 4, 100, "Tomato Stand");
        			tomatoStandBuyTile.onFullyPaid = function()
        			{
        			    console.log("i'm done!");
        			    
        			    scene.add(new TomatoStand(1, 4));
        			    scene.remove(tomatoStandBuyTile.label);
        			    scene.remove(tomatoStandBuyTile);
        			};
        			scene.add(tomatoStandBuyTile);
        			
					const tomatoPlant1 = new TomatoPlant();
        			tomatoPlant1.position.x = -10;
        			tomatoPlant1.position.y = -3;
        			scene.add(tomatoPlant1);
        			
        			const tomatoPlant2 = new TomatoPlant();
        			tomatoPlant2.position.x = -10;
        			tomatoPlant2.position.y = -6;
        			scene.add(tomatoPlant2);
        			
        			this.customers = new Array();
		        }
		        
		        update()
		        {
		            for (const customer of this.customers)
		            {
		                if (customer.actions.length <= 0)
		                {
		                    this.customers.splice(this.customers.indexOf(customer), 1);
		                    scene.remove(customer);
		                }
		            }
		        }
		    }
		    
		    class Customer extends DynamicMesh
		    {
	            constructor()
                {
                    const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    const material = new THREE.MeshBasicMaterial({color: 0xaabbcc});
                    
                    super(geometry, material);
                    
                    this.geometry.computeBoundingBox();
		            this.box = new THREE.Box3();
                    
                    this.elapsedTime = 0;
                    this.actionTime = 3;
                    this.startPosition = new THREE.Vector3(0, 0, 0);
                    this.targetPosition = new THREE.Vector3(0, 0, 0);
                    
                    this.carriedItems = new Array();
                    
                    this.actions = new Array();
                    
                    return this;
                }
                
                pushAction(action)
                {
                    this.actions.push(action);
                    
                    console.log("added action");
                    
                    if (this.actions.length <= 1)
                        this.focusAction(action);
                }
                
                focusAction(action)
                {
                    if (action.type == "move")
                    {
                        console.log("moving to", action.position);
                        this.setTarget(action.position, this.actionTime);
                    }
                        
                    console.log("focused action");
                }
                
                setTarget(endPosition, actionTime)
                {
                    if (!(endPosition instanceof THREE.Vector3))
                    {
                        console.error("endPosition must be a THREE.Vector3");
                        return
                    }
                    
                    this.elapsedTime = 0;
                    this.startPosition.copy(this.position);
                    this.targetPosition.copy(endPosition);
                    this.actionTime = actionTime;
                }
                
                update(deltaTime)
                {
                    if (this.elapsedTime > this.actionTime)
                    {
                        if (this.actions.length > 0)
                        {
                            console.log("action complete");
                            
                            this.actions.shift();
                        
                            if (this.actions.length > 0)
                            {
                                this.focusAction(this.actions[0]);
                                return; // prevents jumping to endPosition and then doing the movement
                            }
                        }
                        
                        this.position.copy(this.targetPosition);
                        return;
                    }
                    
                    this.position.lerpVectors(this.startPosition, this.targetPosition, this.elapsedTime / this.actionTime);
                    
                    this.box.copy(this.geometry.boundingBox).applyMatrix4(this.matrixWorld);
                    
                    this.elapsedTime += deltaTime;
                }
		    };
		    
		    let renderer, htmlRenderer, scene, camera;
		    
		    function prepareThree()
		    {
		        renderer = new THREE.WebGLRenderer({
		            antialias: true,
		            shadowMap: true
		        });
		        renderer.setSize(window.innerWidth, window.innerHeight);
		        document.body.appendChild(renderer.domElement);
		        
    			htmlRenderer = new CSS2DRenderer();
    			htmlRenderer.setSize(window.innerWidth, window.innerHeight);
    			htmlRenderer.domElement.style.position = 'absolute';
    			htmlRenderer.domElement.style.top = '0px';
    			document.body.appendChild(htmlRenderer.domElement).style.pointerEvents = "none";
		        
		        scene = new THREE.Scene();
		        window.scene = scene;
		        // TODO; FIXME: I don't really feel great about this, but it works, so it stays.
		        
		        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		        
                window.addEventListener('resize', (event) =>
                {
					camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
					console.log("Window resized.");
                });
		    }

			function registerEventListeners()
			{
				window.oncontextmenu = function(event)
				{
					event.preventDefault();
					event.stopPropagation();
					return false;
				};

				window.addEventListener("mousemove", (event) =>
				{
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					event.preventDefault();
				});
				
				window.addEventListener("touchmove", (event) =>
				{
					mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2 + 1;
					
					event.preventDefault();
				});

				function moveStart(event)
				{
					moving = true;
					scene.add(moveTarget);
				}

				function moveEnd(event)
				{
					moving = false;
					scene.remove(moveTarget);
				}

				window.addEventListener("mousedown",  moveStart, event);
				window.addEventListener("touchstart", moveStart, event);
				window.addEventListener("mouseup",  moveEnd, event);
				window.addEventListener("touchend", moveEnd, event);

				window.addEventListener("keydown", (event) =>
				{
					keys[event.code] = true;
				});
				
				window.addEventListener("keyup", (event) =>
				{
					keys[event.code] = false;
				});
			}

		    prepareThree();
			registerEventListeners();
		    
		    let shop, player;
		    
			shop = new Shop();
			scene.add(shop);

            player = new Player();
            scene.add(player);
            
            let keys = new Array();
            
            let moving = false;
            
            let moveTarget = new THREE.Mesh(new THREE.SphereGeometry(0.25, 24, 8), new THREE.MeshPhongMaterial({ color: 0x00ffff, 
                                                                                                                 flatShading: true,
                                                                                                                 transparent: true,
                                                                                                                 opacity: 0.7,
                                                                                                                }));
            
            let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

            let mouse = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let intersects = new THREE.Vector3();
            
            const clock = new THREE.Clock();
            
            setInterval(() =>
            {
                let customer = new Customer(shop);
                customer.position.copy(new THREE.Vector3(-9.5, 22, 0));
                customer.pushAction({type: "move", position: new THREE.Vector3(-9.5, 16, 0)});
                customer.pushAction({type: "move", position: new THREE.Vector3(0, 0, 0)});
                customer.pushAction({type: "move", position: new THREE.Vector3(-14, 15, 0)});
                customer.pushAction({type: "move", position: new THREE.Vector3(-9.5, 16, 0)});
                customer.pushAction({type: "move", position: new THREE.Vector3(-9.5, 22, 0)});
                shop.customers.push(customer);
                scene.add(customer);
                
                console.log("added customer");
            }, 5000);

			function animate()
			{
				requestAnimationFrame(animate);
				
				const deltaTime = clock.getDelta();
				
				if (!moving)
				{
    				if (keys["KeyW"] || keys["ArrowUp"])
    				    player.position.y += 0.15;
    			    if (keys["KeyA"] || keys["ArrowLeft"])
    			        player.position.x -= 0.15;
    		        if (keys["KeyS"] || keys["ArrowDown"])
    				    player.position.y -= 0.15;
    				if (keys["KeyD"] || keys["ArrowRight"])
    				    player.position.x += 0.15;
			    }
			    else
			    {
    			    raycaster.setFromCamera(mouse, camera);
                    raycaster.ray.intersectPlane(plane, intersects);
                    moveTarget.position.set(intersects.x, intersects.y, intersects.z);
    			    
                    player.lookAt(moveTarget.position);
    			    player.position.lerp(moveTarget.position, 0.03);
			    }
				
				camera.position.copy(player.position);
				camera.position.z = 10;
				camera.position.y -= 8;
    			camera.lookAt(player.position);
    			camera.position.y += 5;
    			
                scene.children.forEach( (object) =>
                {
                    if (object instanceof DynamicMesh)
                        object.update(deltaTime);
                        
                    if (object instanceof Interactable)
                        if (player.box.intersectsBox(object.trigger))
                            object.onTrigger(player);
                        else if (object.triggered)
                            object.onStopTrigger(player);
                });
                
				renderer.render(scene, camera);
				htmlRenderer.render(scene, camera);
			};
			
			/*
			if (document.webkitFullscreenElement) 
			{
                document.webkitCancelFullScreen();
            }
            else
            {
                const el = document.documentElement;
                el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
            */

			animate();
		</script>
	</body>
</html>