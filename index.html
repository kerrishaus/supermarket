<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>let's go shoppin</title>
		<style>
	        *
			{
			    pointer-events: none;
			    user-select: none;
			    -webkit-user-select: none;
			}

			html, body
			{
			    margin: 0;
			    background-color: black;
                overflow-x: hidden;
                
                height: 100%;
                width: 100%;
                
                overflow-x: hidden;
                overflow-y: hidden;
            }

            body
            {
                position: relative;
            }
		</style>

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		
		<script src="https://kerrishaus.com/assets/scripts/jquery-3.6.0.min.js"></script>
		<script src="https://portal.kerrishaus.com/assets/javascript/messages.js"></script>
		<link rel='stylesheet' href='https://portal.kerrishaus.com/assets/styles/messages.css'>

	    <style>
	        .banner
	        {
	            color: white;
	            
	            background-color: white;
	            border-bottom: 1px solid white;
	            
	            display: flex;
	            gap: 1px;
	            
	            position: absolute;
	            top: 0px;
	            left: 0px;
	            
	            width: 100vw;
	        }

	        .banner > div
	        {
	            padding: 3px;
	            background-color: #222;
	            flex-grow: 1;
	        }
	    </style>
	</head>
	<body>
	    
	    <div class='banner'>
	        <div>
	            $<span id='money'>0</span>
	        </div>
	        <div id='reputation'>
	            rep <span>0</span>
	        </div>
	    </div>
	    
	    <div class='buttons'>
	        <div class='upgrades'>
	            
	        </div>
	    </div>
	    
		<script type='module'>
		    import * as THREE from "https://kerrishaus.com/assets/threejs/build/three.module.js";
		    import { CSS2DObject, CSS2DRenderer } from "https://kerrishaus.com/assets/threejs/examples/jsm/renderers/CSS2DRenderer.js";
		    import { TransformControls } from 'https://kerrishaus.com/assets/threejs/examples/jsm/controls/TransformControls.js';

		    function createCube(color)
		    {
		        const geometry = new THREE.BoxGeometry(1, 1, 1);
		        const material = new THREE.MeshBasicMaterial({ color: color });
		        
		        return new THREE.Mesh(geometry, material);
		    }
		    
		    function createObject(size, position, color)
		    {
		        const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
		        const material = new THREE.MeshBasicMaterial({color: color});
		        
		        const mesh = new THREE.Mesh(geometry, material);
		        mesh.position.copy(position);
		        
		        return mesh;
		    }
		    
		    function createScaledCube(width, height, thickness, color)
		    {
		        const geometry = new THREE.BoxGeometry(width, height, thickness);
		        const material = new THREE.MeshBasicMaterial({ color: color });
		        
		        return new THREE.Mesh(geometry, material);
		    }
		    
		    class DynamicMesh extends THREE.Mesh
		    {
		        constructor(geometry, material)
		        {
		            super(geometry, material);
		        }
		        
		        update()
		        {
		            
		        }
		    };
		    
		    class Interactable extends DynamicMesh
		    {
		        constructor(width, length, triggerWidth, triggerLength, color)
		        {
		            const geometry = new THREE.BoxGeometry(width, length, 1);
		            const material = new THREE.MeshBasicMaterial({ color: color });
		            
		            super(geometry, material);
		            
		            const triggerGeometry = new THREE.BoxGeometry(triggerWidth, triggerLength, 0.1);
		            const triggerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2 });
		            
		            this.triggerObject = new THREE.Mesh(triggerGeometry, triggerMaterial);
		            this.triggerObject.geometry.computeBoundingBox();
		            this.attach(this.triggerObject);
		            this.triggerObject.position.z -= 0.4;
		            
		            this.trigger = new THREE.Box3();
		            
		            this.triggered = false;
		            this.triggeringObject = null;
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            this.trigger.copy(this.triggerObject.geometry.boundingBox).applyMatrix4(this.triggerObject.matrixWorld);
		        }
		        
		        onTrigger(object)
		        {
		            this.triggered = true;
		            this.triggeringObject = object;
		            
		            this.triggerObject.material.color.setHex(0x00ff00);
		        }
		        
		        onStopTrigger(object)
		        {
		            if (!this.triggered)
		                return;
		                
	                this.triggered = false;
	                this.triggeringObject = null;
	                
	                this.triggerObject.material.color.setHex(0xff0000);
		        }
		    };
		    
		    class Carryable extends DynamicMesh
		    {
		        constructor(width, height, thickness, color)
		        {
		            const geometry = new THREE.BoxGeometry(width, height, thickness);
		            const material = new THREE.MeshBasicMaterial({color: color});
		            
		            super(geometry, material);
		            
		            this.offset         = new THREE.Vector3(0, 0, 0);
		            this.owner          = new THREE.Vector3(0, 0, 0);
		            this.targetPosition = new THREE.Vector3(0, 0, 0);
		            this.startPosition  = new THREE.Vector3(0, 0, 0);
		            
		            this.elapsedTime = 0;
		            this.moveTime = 0.4;
		            
		            this.autoPositionAfterAnimation = true;
		        }
		        
		        setTarget(owner, offset)
		        {
		            this.startPosition.copy(this.position);
		            this.updateTarget(owner, offset);
		            this.elapsedTime = 0;
		        }
		        
		        updateTarget(owner, offset)
		        {
		            if (!(owner instanceof THREE.Vector3))
		            {
		                console.error("owner not instance of Vector3", owner);
		                return
		            }
		            
		            if (!(offset instanceof THREE.Vector3))
		            {
		                console.error("offset not instance of Vector3", offset);
		                return
		            }
		            
		            this.owner.copy(owner);
		            this.offset.copy(offset);
		            
		            this.targetPosition = new THREE.Vector3(this.owner.x + this.offset.x,
	                                                        this.owner.y + this.offset.y,
		                                                    this.owner.z + this.offset.z);
		        }
		        
		        update(deltaTime)
		        {
		            if (this.elapsedTime > this.moveTime)
		            {
		                if (this.autoPositionAfterAnimation)
		                    this.position.copy(this.targetPosition);
		                    
		                return;
		            }
		            
                    this.elapsedTime += deltaTime;
                    this.position.lerpVectors(this.startPosition, this.targetPosition, this.elapsedTime / this.moveTime);
		        }
		    };
		    
		    class RecycleBin extends Interactable
		    {
		        constructor(xPos, yPos)
		        {
		            super(1, 1, 2, 2, 0x00ff00);
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
		            this.timeSinceLastRecycle = 0;
		            this.recycleInterval = 0.2;
		            
		            this.carriedItems = new Array();
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            this.timeSinceLastRecycle += deltaTime;
		            
		            for (const item of this.carriedItems)
		                if (item.elapsedTime > item.moveTime)
		                {
		                    this.carriedItems.splice(this.carriedItems.indexOf(item), 1);
		                    scene.remove(item);
		                }
		        }
		        
		        recycleItem(holder)
		        {
		            if (holder.carriedItems.length <= 0)
		                return;
		                
                    const item = holder.carriedItems[holder.carriedItems.length - 1]
                    holder.carriedItems.splice(holder.carriedItems.indexOf(holder), 1);
                    this.carriedItems.push(item);
                    item.setTarget(this.position, new THREE.Vector3(0, 0, 0));
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
	                    if (this.timeSinceLastRecycle > this.recycleInterval)   
                        {
                            this.recycleItem(player);
                            this.timeSinceLastRecycle = 0;
                        }
	                    
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    }
		    
		    class BuyableTile extends Interactable
		    {
		        constructor(width, length, xPos, yPos, price, name)
		        {
		            super(width, length, width + 3, length + 3, 0xff0000);
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
                    const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'buyableTileTitle';
        			labelDiv.textContent = name;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
        			
        			this.carriedMoney = new Array();
        			
		            this.price = price;
		            this.pricePaid = 0;
		            
		            this.onFullyPaid = function() {};
		        }
		        
                transferMoney(player)
		        {
		            if (player.money <= 0)
		                return;
		                
		            const money = new Carryable(0.3, 0.2, 0.02, 0x48c942);
                    money.position.copy(this.position);
                    money.setTarget(this.position, new THREE.Vector3(0, 0, 0));
                    money.startPosition.copy(player.position);
                    scene.add(money);
                    
		            this.carriedMoney.push(money);
		            this.pricePaid += 1;
		            player.money -= 1;
		            
		            if (this.pricePaid == this.price)
		            {
		                this.onFullyPaid();
		                return;
		            }
		            
		            this.label.element.textContent = this.price - this.pricePaid;
		            $("#money").html(player.money);
		        }
		        
		        update(deltaTime)
		        {
                    super.update();
                 
                    for (const money of this.carriedMoney)
                    {
                        if (money.elapsedTime > money.moveTime)
                        {
                            scene.remove(money);
                            this.carriedMoney.splice(this.carriedMoney.indexOf(money), 1);
                            continue;
                        }
                        
                        money.startPosition.copy(player.position);
                    }
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferMoney(object);
		        }
		    };
		    
		    class Tomato extends Carryable
		    {
		        constructor(position)
		        {
		            super(0.4, 0.4, 0.4, 0x852520);
		            
		            this.position.copy(position);
		        }
		    };
		    
		    class TomatoPlant extends Interactable
		    {
		        constructor()
		        {
		            super(0.2, 0.2, 1, 1, 0xff0000);
		            
		            this.name = "tomatoPlant";
		            
		            this.timeSinceLastGrowth = 0;
		            this.tomatoes = new Array();
		            
                    const labelDiv = document.createElement("div");
    				labelDiv.id = this.uuid;
        			labelDiv.className = 'unitCount';
        			labelDiv.textContent = this.tomatoes.length;
        			
        			this.label = new CSS2DObject(labelDiv);
        			this.label.color = "white";
        			this.add(this.label);
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            if (this.tomatoes.length < 3)
    		            if (this.timeSinceLastGrowth > 3)
    		            {
    		                this.grow();
    		                this.timeSinceLastGrowth = 0;
    		            }
		            
		            this.timeSinceLastGrowth += deltaTime;
		        }
		        
		        grow()
		        {
		            const newTomato = new Tomato(this.position);
		            newTomato.setTarget(this.position, new THREE.Vector3(0, 1, 0));
		            this.tomatoes.push(newTomato);
		            scene.add(newTomato);
		            
		            this.label.element.textContent = this.tomatoes.length;
		        }
		        
		        transferTomato(receiver)
		        {
		            if (this.tomatoes.length <= 0)
		                return;
		                
		            const tomato = this.tomatoes[this.tomatoes.length - 1];
		            tomato.carryPos = receiver.carriedItems.length + 1;
		            tomato.moveTime = 0.17;
		            
		            // TODO: I want to set the offset vector here, in the future
		            // but right now it's really not required because it will set by
		            // updateTarget later in Player#update
		            tomato.setTarget(receiver.position, new THREE.Vector3(0, 0, 0));
		            tomato.autoPositionAfterAnimation = false;
		            
		            receiver.carriedItems.push(tomato);
		            
		            this.tomatoes.pop();
		            this.label.element.textContent = this.tomatoes.length;
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferTomato(object);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class TomatoStand extends Interactable
		    {
		        constructor(xPos, yPos)
		        {
		            super(1, 1, 2, 2, 0x4d220b);
		            
		            this.name = "tomatoStand";
		            
		            this.position.x = xPos;
		            this.position.y = yPos;
		            
		            this.carriedItems = new Array();
		            this.maxItems = 9;
		        }
		        
		        captureHeldTomato(holder)
		        {
		            if (this.carriedItems.length >= this.maxItems)
		                return;
		            
		            for (const item of holder.carriedItems)
		            {
		                if (item instanceof Tomato)
		                {
		                    holder.carriedItems.splice(holder.carriedItems.indexOf(item), 1);
		                    this.carriedItems.push(item);
		                    
		                    const rows = 3;
                            const columns = 3;
                            const totalPerStack = rows * columns;
		                    
                            let stacks = Math.floor(this.carriedItems.length / totalPerStack);
                            let currentStack = this.carriedItems.length - (stacks * totalPerStack);
                            let row = Math.floor(currentStack / rows);
                            let column = currentStack - (row * columns);
		                    
		                    item.setTarget(this.position, new THREE.Vector3(column - 1, row - 1, 1));
		                    item.autoPositionAfterAnimation = true;
		                }
		            }
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.captureHeldTomato(player);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class Door extends Interactable
		    {
		        constructor(position)
		        {
		            super(3, 3, 6, 4, 0x000000);
		            
		            this.name = "door";
		            
		            this.position.copy(position);
		            this.material.transparent = true;
		            this.material.opacity = 0;
		            
		            this.leftDoor = new Carryable(2, 1, 4, 0x00d1e8);
		            this.leftDoor.setTarget(new THREE.Vector3(-8.5, 19.4, 1), new THREE.Vector3(0, 0, 0));
		            
		            this.leftDoor.add(createObject(new THREE.Vector3(0.2, 0.1, 4), new THREE.Vector3(-0.9, -0.55, 0), 0x919191));
		            this.leftDoor.add(createObject(new THREE.Vector3(0.2, 0.1, 4), new THREE.Vector3(0.9, -0.55, 0), 0x919191));
		            
		            this.leftDoor.add(createObject(new THREE.Vector3(1.6, 0.1, 0.2), new THREE.Vector3(0, -0.55, 1.9), 0x919191));
		            this.leftDoor.add(createObject(new THREE.Vector3(1.6, 0.1, 0.2), new THREE.Vector3(0, -0.55, 0.1), 0x919191));
		            this.leftDoor.add(createObject(new THREE.Vector3(1.6, 0.1, 0.2), new THREE.Vector3(0, -0.55, -1.4), 0x919191));
		            
		            this.rightDoor = new Carryable(2, 1, 4, 0x00d1e8)
		            this.rightDoor.setTarget(new THREE.Vector3(-10.5, 19.4, 1), new THREE.Vector3(0, 0, 0));
		            this.rightDoor.add(createObject(new THREE.Vector3(0.2, 0.1, 4), new THREE.Vector3(-0.9, -0.55, 0), 0x919191));
		            this.rightDoor.add(createObject(new THREE.Vector3(0.2, 0.1, 4), new THREE.Vector3(0.9, -0.55, 0), 0x919191));
		            
		            this.rightDoor.add(createObject(new THREE.Vector3(1.6, 0.1, 0.2), new THREE.Vector3(0, -0.55, 1.9), 0x919191));
		            this.rightDoor.add(createObject(new THREE.Vector3(1.6, 0.1, 0.2), new THREE.Vector3(0, -0.55, 0.1), 0x919191));
		            this.rightDoor.add(createObject(new THREE.Vector3(1.6, 0.1, 0.2), new THREE.Vector3(0, -0.55, -1.4), 0x919191));
		            
		            scene.add(createObject(new THREE.Vector3(4, 1, 4), new THREE.Vector3(-9.5, 19.45, 0.99), 0x000000));
		            
		            scene.add(this.leftDoor);
		            scene.add(this.rightDoor);
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		        }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            this.rightDoor.setTarget(new THREE.Vector3(-12.5, 19.4, 1), new THREE.Vector3(0, 0, 0));
		            this.leftDoor.setTarget(new THREE.Vector3(-6.5, 19.4, 1), new THREE.Vector3(0, 0, 0));
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		            
		            this.rightDoor.setTarget(new THREE.Vector3(-10.5, 19.4, 1), new THREE.Vector3(0, 0, 0));
		            this.leftDoor.setTarget(new THREE.Vector3(-8.5, 19.4, 1), new THREE.Vector3(0, 0, 0));
		        }
		    }
		    
		    class Register extends Interactable
		    {
		        constructor()
		        {
		            super(2, 4, 4, 6, 0xad723e);
		            
		            this.name = "register";
		            
        			this.money = new Array();
		            this.timeSinceLastMoney = 0;
		            
                    this.column_ = 0;
                    this.row_ = 0;
                    this.layer_ = 0;
                    
                    this.gridRows = 9;
                    this.gridColumns = 4;
		            
		            this.moneyLength = 0.3;
                    this.moneyWidth = 0.2;
                    this.moneyThickness = 0.2;
		        }
		        
		        update(deltaTime)
		        {
		            super.update(deltaTime);
		            
		            if (this.timeSinceLastMoney >= 0.1)
		            {
		                this.addMoney();
		                this.timeSinceLastMoney = 0;
		            }
		            
		            this.timeSinceLastMoney += deltaTime
		        }
		        
		        addMoney()
                {
                    this.calculateGrid();
                    
                    const money = new Carryable(this.moneyLength, this.moneyWidth, this.moneyThickness, 0x48c942);
                    money.position.copy(this.position);
                    money.setTarget(this.position, new THREE.Vector3(this.column_ * this.moneyLength,
                                                                     this.row_ * this.moneyWidth,
                                                                     (this.scale.z / 2) + (this.layer_ * this.moneyThickness)));
                    
                    scene.add(money);
                    this.money.push(money);
		        }
		        
		        transferMoney(player)
		        {
		            if (this.money.length <= 0)
		                return;
		                
		            const money = this.money[this.money.length - 1];
		            
		            //money.parent.remove(money);
                    //money.matrixWorld.decompose(money.position, money.quaternion, money.scale);
		            money.setTarget(player.position, new THREE.Vector3(0, 0, 0));
		            
		            player.carriedMoney.push(money);
		            
		            this.money.pop();
		            
		            this.calculateGrid();
		            
		            player.money += 1;
		            $("#money").html(player.money);
		        }
		        
                calculateGrid()
                {
                    this.column_ = 0;
                    this.row_    = 0;
                    this.layer_  = 0;
                    
                    for (let i = 0; i < this.money.length; i++)
                    {
                        this.column_ += 1;
                        
                        if (this.column_ >= this.gridColumns)
                        {
                            this.column_ = 0;
                            this.row_ += 1;
                        }
                        
                        if (this.row_ >= this.gridRows)
                        {
                            this.row_ = 0;
                            this.layer_ += 1;
                        }
                    }
                }
		        
		        onTrigger(object)
		        {
		            super.onTrigger(object);
		            
		            if (object instanceof Player)
		                this.transferMoney(object);
		        }
		        
		        onStopTrigger(object)
		        {
		            super.onStopTrigger(object);
		        }
		    };
		    
		    class Shop extends DynamicMesh
		    {
		        constructor()
		        {
		            super();
		            
		            // shop floor
		            scene.add(createObject(new THREE.Vector3(40, 20, 1), new THREE.Vector3(0, 10, -1), 0xE0E0E0));
		            // shop north wall
		            scene.add(createObject(new THREE.Vector3(40, 1, 4), new THREE.Vector3(0, 19.5, 1.5), 0xbfbfbf));
		            // west wall
		            scene.add(createObject(new THREE.Vector3(1, 20, 4), new THREE.Vector3(-19.5, 10, 1.5), 0xbfbfbf));
		            // east wall
		            scene.add(createObject(new THREE.Vector3(1, 20, 4), new THREE.Vector3(19.5, 10, 1.5), 0xbfbfbf));
		            
		            this.doors = new Door(new THREE.Vector3(-9.5, 19.4, 0), 0x0000ff);
		            scene.add(this.doors);
		            
		            // farm floor
		            scene.add(createObject(new THREE.Vector3(40, 20, 1), new THREE.Vector3(0, -10, -1), 0x44CD32));
		            
		            this.register = new Register();
        			this.register.position.x = -16;
        			this.register.position.y = 15;
        			for (let i = 0; i < 100; i++)
                        this.register.addMoney();
		            scene.add(this.register);
		            
        			this.recycleBin = new RecycleBin(6, 4);
        			this.recycleBin.position.x = -4;
        			this.recycleBin.position.y = 17;
        			scene.add(this.recycleBin);
        			
					let tomatoStandBuyTile = new BuyableTile(1, 1, 1, 4, 100, "Tomato Stand");
        			tomatoStandBuyTile.onFullyPaid = function()
        			{
        			    console.log("i'm done!");
        			    
        			    scene.add(new TomatoStand(1, 4));
        			    scene.remove(tomatoStandBuyTile.label);
        			    scene.remove(tomatoStandBuyTile);
        			};
        			scene.add(tomatoStandBuyTile);
        			
					const tomatoPlant1 = new TomatoPlant();
        			tomatoPlant1.position.x = -10;
        			tomatoPlant1.position.y = -3;
        			scene.add(tomatoPlant1);
        			
        			const tomatoPlant2 = new TomatoPlant();
        			tomatoPlant2.position.x = -10;
        			tomatoPlant2.position.y = -6;
        			scene.add(tomatoPlant2);
        			
        			this.customers = new Array();
		        }
		        
		        update()
		        {
		            for (const customer of this.customers)
		            {
		                if (customer.actions.length <= 0)
		                {
		                    this.customers.splice(this.customers.indexOf(customer), 1);
		                    scene.remove(customer);
		                }
		            }
		        }
		    }
		    
		    class Customer extends DynamicMesh
		    {
	            constructor()
                {
                    const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    const material = new THREE.MeshBasicMaterial({color: 0xaabbcc});
                    
                    super(geometry, material);
                    
                    this.geometry.computeBoundingBox();
		            this.box = new THREE.Box3();
                    
                    this.elapsedTime = 0;
                    this.actionTime = 3;
                    this.startPosition = new THREE.Vector3(0, 0, 0);
                    this.targetPosition = new THREE.Vector3(0, 0, 0);
                    
                    this.carriedItems = new Array();
                    
                    this.actions = new Array();
                    
                    return this;
                }
                
                pushAction(action)
                {
                    this.actions.push(action);
                    
                    console.log("added action");
                    
                    if (this.actions.length <= 1)
                        this.focusAction(action);
                }
                
                focusAction(action)
                {
                    if (action.type == "move")
                    {
                        console.log("moving to", action.position);
                        this.setTarget(action.position, this.actionTime);
                    }
                        
                    console.log("focused action");
                }
                
                setTarget(endPosition, actionTime)
                {
                    if (!(endPosition instanceof THREE.Vector3))
                    {
                        console.error("endPosition must be a THREE.Vector3");
                        return
                    }
                    
                    this.elapsedTime = 0;
                    this.startPosition.copy(this.position);
                    this.targetPosition.copy(endPosition);
                    this.actionTime = actionTime;
                }
                
                update(deltaTime)
                {
                    if (this.elapsedTime > this.actionTime)
                    {
                        if (this.actions.length > 0)
                        {
                            console.log("action complete");
                            
                            this.actions.pop();
                        
                            if (this.actions.length > 0)
                                this.focusAction(this.actions[this.actions.length - 1]);
                        }
                        
                        this.position.copy(this.targetPosition);
                        return;
                    }
                    
                    this.position.lerpVectors(this.startPosition, this.targetPosition, this.elapsedTime / this.actionTime);
                    
                    this.box.copy(this.geometry.boundingBox).applyMatrix4(this.matrixWorld);
                    
                    this.elapsedTime += deltaTime;
                }
		    };
		    
		    class Player extends DynamicMesh
		    {
		        constructor()
		        {
		            const geometry = new THREE.BoxGeometry(1, 1, 1);
		            const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
		            
		            super(geometry, material);
		            
		            this.geometry.computeBoundingBox();
		            
		            this.box = new THREE.Box3();
		            
		            this.money = 0;
		            
		            this.carriedItems = new Array();
		            this.carriedMoney = new Array();
		        }
		        
		        update(deltaTime)
		        {
		            this.box.copy(this.geometry.boundingBox).applyMatrix4(this.matrixWorld);
		            
		            for (const item of this.carriedItems)
		            {
		                const carryPos = 1 + (item.scale.z * item.carryPos);
		                
		                if (item.elapsedTime > item.moveTime)
	                    {
	                        item.position.copy(this.position);
	                        item.position.z += carryPos;
	                        continue;
	                    }
	                    
	                    item.updateTarget(this.position, new THREE.Vector3(0, 0, carryPos));
		            }

	                for (const money of this.carriedMoney)
	                {
	                    if (money.elapsedTime > money.moveTime)
	                    {
	                        scene.remove(money);
	                        this.carriedMoney.splice(this.carriedMoney.indexOf(money), 1);
	                        continue;
	                    }
	                    
	                    money.updateTarget(player.position, new THREE.Vector3(0, 0, 0));
	                }
		        }
		    };

			const scene = new THREE.Scene();

			const renderer = new THREE.WebGLRenderer({
			    antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const htmlRenderer = new CSS2DRenderer();
			htmlRenderer.setSize(window.innerWidth, window.innerHeight);
			htmlRenderer.domElement.style.position = 'absolute';
			htmlRenderer.domElement.style.top = '0px';
			document.body.appendChild(htmlRenderer.domElement).style.pointerEvents = "none";
			
			const shop = new Shop();
			scene.add(shop);

            const player = new Player();
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(player);
            
            window.oncontextmenu = function(event)
            {
                 event.preventDefault();
                 event.stopPropagation();
                 return false;
            };
            
            $(document).resize((event) =>
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            });

            let keys = new Array();

            $(document).keydown(function(event)
            {
                keys[event.code] = true;
            });
            
            $(document).keyup(function(event)
            {
                keys[event.code] = false;
            });
            
            let moving = false;
            
            $(document).on('mousedown touchstart', (event) =>
            {
                moving = true;
                
                scene.add(moveTarget);
            });
            
            $(document).on('mouseup touchend', (event) =>
            {
                moving = false;
                
                scene.remove(moveTarget);
            });
            
            let moveTarget = new THREE.Mesh(new THREE.SphereGeometry(0.25, 24, 8), new THREE.MeshPhongMaterial({ color: 0x00ffff, 
                                                                                                                 flatShading: true,
                                                                                                                 transparent: true,
                                                                                                                 opacity: 0.7,
                                                                                                                }));
            
            let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

            let mouse = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let intersects = new THREE.Vector3();
            
            $(document).on('mousemove', (event) =>
            {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            });
            
            $(document).on('touchmove', (event) =>
            {
                mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2 + 1;
                
                event.preventDefault();
            });
            
            const clock = new THREE.Clock();
            
            setInterval(() =>
            {
                let customer = new Customer(shop);
                customer.position.copy(new THREE.Vector3(-9.5, 22, 0));
                customer.pushAction({type: "move", position: new THREE.Vector3(-9.5, 16, 0)});
                customer.pushAction({type: "move", position: new THREE.Vector3(0, 0, 0)});
                customer.pushAction({type: "move", position: new THREE.Vector3(12, 16, 0)});
                shop.customers.push(customer);
                scene.add(customer);
                
                console.log("added customer");
            }, 5000);

			function animate()
			{
				requestAnimationFrame(animate);
				
				const deltaTime = clock.getDelta();
				
				if (!moving)
				{
    				if (keys["KeyW"] || keys["ArrowUp"])
    				    player.position.y += 0.15;
    			    if (keys["KeyA"] || keys["ArrowLeft"])
    			        player.position.x -= 0.15;
    		        if (keys["KeyS"] || keys["ArrowDown"])
    				    player.position.y -= 0.15;
    				if (keys["KeyD"] || keys["ArrowRight"])
    				    player.position.x += 0.15;
			    }
			    else
			    {
    			    raycaster.setFromCamera(mouse, camera);
                    raycaster.ray.intersectPlane(plane, intersects);
                    moveTarget.position.set(intersects.x, intersects.y, intersects.z);
    			    
                    player.lookAt(moveTarget.position);
    			    player.position.lerp(moveTarget.position, 0.03);
			    }
				
				camera.position.copy(player.position);
				camera.position.z = 10;
				camera.position.y -= 8;
    			camera.lookAt(player.position);
    			camera.position.y += 5;
    			
                scene.children.forEach( (object) =>
                {
                    if (object instanceof DynamicMesh)
                        object.update(deltaTime);
                        
                    if (object instanceof Interactable)
                        if (player.box.intersectsBox(object.trigger))
                            object.onTrigger(player);
                        else if (object.triggered)
                            object.onStopTrigger(player);
                });
                
				renderer.render(scene, camera);
				htmlRenderer.render(scene, camera);
			};
			
			/*
			if (document.webkitFullscreenElement) 
			{
                document.webkitCancelFullScreen();
            }
            else
            {
                const el = document.documentElement;
                el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
            */

			animate();
		</script>
	</body>
</html>
