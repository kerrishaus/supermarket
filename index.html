<!DOCTYPE html>
<html>
	<head>
		<title>let's go shoppin</title>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		
		<link rel='stylesheet' href='./styles/game.css'>
		<link rel='stylesheet' href='./styles/interface.css'>
		
		<script src="https://kerrishaus.com/assets/scripts/jquery-3.6.0.min.js"></script>
		<script src="https://portal.kerrishaus.com/assets/javascript/messages.js"></script>
		<link rel='stylesheet' href='https://portal.kerrishaus.com/assets/styles/messages.css'>
	</head>

	<body>
	    <div class='banner'>
	        <div>
	            $<span id='money'>0</span>
	        </div>
	        <div id='reputation'>
	            rep <span>0</span>
	        </div>
	    </div>
	    
	    <div class='buttons'>
	        <div class='upgrades'>
	            
	        </div>
	    </div>
	    
		<script type='module'>
			import AmmoLib from "https://kerrishaus.com/assets/ammojs/ammo.module.js";
			let Ammo;

		    import * as THREE from "https://kerrishaus.com/assets/threejs/build/three.module.js";
		    import { CSS2DObject, CSS2DRenderer } from "https://kerrishaus.com/assets/threejs/examples/jsm/renderers/CSS2DRenderer.js";
		    import { TransformControls } from 'https://kerrishaus.com/assets/threejs/examples/jsm/controls/TransformControls.js';
		    
			import * as GeometryUtil from "./scripts/GeometryUtility.js";

			import { PhysicsScene } from "./scripts/PhysicsScene.js";

			import { PhysicsMesh } from "./scripts/PhysicsMesh.js";
		    import { DynamicMesh } from "./scripts/DynamicMesh.js";

			import { RigidBodyCube } from "./scripts/RigidBodyCube.js";
			import { RigidBodySphere } from "./scripts/RigidBodySphere.js";
			import { KinematicCube } from "./scripts/KinematicCube.js";

		    import { Interactable } from "./scripts/InteractableMesh.js";
			import { Carryable } from "./scripts/Carryable.js";

			import { Shop } from "./scripts/Shop.js";
		    import { RecycleBin } from "./scripts/RecycleBin.js";
			import { Door } from "./scripts/Door.js";
		    import { Player } from "./scripts/Player.js";
			import { Tomato } from "./scripts/Tomato.js";
			import { TomatoPlant } from "./scripts/TomatoPlant.js";
			import { TomatoStand } from "./scripts/TomatoStand.js";
			import { BuyableTile } from "./scripts/BuyableTile.js";
		    
		    let renderer, htmlRenderer, scene, camera;
		    
		    function prepareThree()
		    {
				console.log("Preparing Three.");

		        renderer = new THREE.WebGLRenderer({
		            antialias: true,
		            shadowMap: true
		        });
		        renderer.setSize(window.innerWidth, window.innerHeight);
		        document.body.appendChild(renderer.domElement);
		        
    			htmlRenderer = new CSS2DRenderer();
    			htmlRenderer.setSize(window.innerWidth, window.innerHeight);
    			htmlRenderer.domElement.style.position = 'absolute';
    			htmlRenderer.domElement.style.top = '0px';
    			document.body.appendChild(htmlRenderer.domElement).style.pointerEvents = "none";
		        
		        scene = new PhysicsScene();
		        window.scene = scene;
		        // TODO: FIXME: I don't really feel great about this, but it works, so it stays.
		        
		        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		        
                window.addEventListener('resize', (event) =>
                {
					camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
					console.log("Window resized.");
                });

				console.log("Three is ready.");
		    }

			window.collisionConfiguration_ = null;
			window.dispatcher_ 			   = null;
			window.broadphase_             = null;
			window.solver_				   = null;
			window.physicsWorld            = null;
			window.physicsBodies 		   = new Array();
			window.tmpTransform 		   = null;

			function prepareAmmo(lib)
			{
				console.log("Preparing Ammo.");

				Ammo = lib;
				window.Ammo = lib;

				collisionConfiguration_ = new Ammo.btDefaultCollisionConfiguration();
				dispatcher_  			= new Ammo.btCollisionDispatcher(collisionConfiguration_);
				broadphase_  			= new Ammo.btDbvtBroadphase();
				solver_      			= new Ammo.btSequentialImpulseConstraintSolver();
				physicsWorld 			= new Ammo.btDiscreteDynamicsWorld(dispatcher_, broadphase_, solver_, collisionConfiguration_);
				physicsWorld.setGravity(new Ammo.btVector3(0, 0, -100));

				tmpTransform = new Ammo.btTransform();

				console.log("Ammo is ready.");
			}

			function registerEventListeners()
			{
				window.oncontextmenu = function(event)
				{
					event.preventDefault();
					event.stopPropagation();
					return false;
				};

				window.addEventListener("mousemove", (event) =>
				{
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					event.preventDefault();
				});
				
				window.addEventListener("touchmove", (event) =>
				{
					mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2 + 1;
					
					event.preventDefault();
				});

				function moveStart(event)
				{
					moving = true;
					scene.add(moveTarget);
				}

				function moveEnd(event)
				{
					moving = false;
					scene.remove(moveTarget);
				}

				window.addEventListener("mousedown",  moveStart, event);
				window.addEventListener("touchstart", moveStart, event);
				window.addEventListener("mouseup",  moveEnd, event);
				window.addEventListener("touchend", moveEnd, event);

				window.addEventListener("keydown", (event) =>
				{
					keys[event.code] = true;
				});
				
				window.addEventListener("keyup", (event) =>
				{
					keys[event.code] = false;
				});
			}
		    
		    let shop, player;
		    
            let keys = new Array();
            let moving = false;
            
            let moveTarget = new THREE.Mesh(new THREE.SphereGeometry(0.25, 24, 8), new THREE.MeshPhongMaterial({ color: 0x00ffff, 
                                                                                                                 flatShading: true,
                                                                                                                 transparent: true,
                                                                                                                 opacity: 0.7,
                                                                                                                }));
            
																												let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

            let mouse = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let intersects = new THREE.Vector3();
            
            const clock = new THREE.Clock();

			function prepareGame()
			{
				console.log("Preparing game.");

				shop = new Shop();
				scene.add(shop);
	
				player = new Player();
				scene.add(player);

				console.log("Game is ready.");
			}

			function physicsStep(deltaTime)
			{
				physicsWorld.stepSimulation(deltaTime, 10);

				for (const object of physicsBodies)
				{
					object.motionState.getWorldTransform(tmpTransform);

					if (object.isKinematic())
					{
						//object.transform.setOrigin(new Ammo.btVector3(object.position.x, object.position.y, object.position.z));
        				//object.transform.setRotation(new Ammo.btQuaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w));
						continue;
					}
					else
					{
						const pos = tmpTransform.getOrigin();
						const quat = tmpTransform.getRotation();
						const pos3 = new THREE.Vector3(pos.x(), pos.y(), pos.z());
						const quat3 = new THREE.Quaternion(quat.x(), quat.y(), quat.z(), quat.w());
						
						object.position.copy(pos3);
						object.quaternion.copy(quat3);
					}
				}

				//detectCollision();
			}

			function detectCollision()
			{
				let dispatcher = physicsWorld.getDispatcher();
				let numManifolds = dispatcher.getNumManifolds();

				for ( let i = 0; i < numManifolds; i ++ )
				{
					let contactManifold = dispatcher.getManifoldByIndexInternal( i );
					let numContacts = contactManifold.getNumContacts();

					for ( let j = 0; j < numContacts; j++ )
					{
						let contactPoint = contactManifold.getContactPoint( j );
						let distance = contactPoint.getDistance();

						if (distance > 0.0)
							continue;

						console.log({manifoldIndex: i, contactIndex: j, distance: distance});
					}
				}
			}
			
			function animate()
			{
				requestAnimationFrame(animate);
				
				const deltaTime = clock.getDelta();

				if (!moving)
				{
					let moveDirection = { left: 0, right: 0, forward: 0, back: 0 };

					if (keys["KeyW"] || keys["ArrowUp"])
						player.position.y += 0.15;
					if (keys["KeyA"] || keys["ArrowLeft"])
						player.position.x -= 0.15;
					if (keys["KeyS"] || keys["ArrowDown"])
						player.position.y -= 0.15;
					if (keys["KeyD"] || keys["ArrowRight"])
						player.position.x += 0.15;
				}
			    else
			    {
    			    raycaster.setFromCamera(mouse, camera);
                    raycaster.ray.intersectPlane(plane, intersects);
                    moveTarget.position.set(intersects.x, intersects.y, intersects.z);
    			    
                    player.lookAt(moveTarget.position);
    			    player.position.lerp(moveTarget.position, 0.03);
			    }
				
				camera.position.copy(player.position);
				camera.position.z = 10;
				camera.position.y -= 8;
    			camera.lookAt(player.position);
    			camera.position.y += 5;

                scene.children.forEach( (object) =>
                {
                    if (object instanceof DynamicMesh)
                        object.update(deltaTime);
                    
					/*
                    if (object instanceof Interactable)
                        if (player.box.intersectsBox(object.trigger))
                            object.onTrigger(player);
                        else if (object.triggered)
                            object.onStopTrigger(player);
					*/
                });

				physicsStep(deltaTime);
                
				renderer.render(scene, camera);
				htmlRenderer.render(scene, camera);
			};
			
			/*
			if (document.webkitFullscreenElement) 
			{
                document.webkitCancelFullScreen();
            }
            else
            {
                const el = document.documentElement;
                el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
            */

			window.addEventListener('DOMContentLoaded', async () =>
            {
                AmmoLib().then((lib) =>
                {
					prepareThree();
					prepareAmmo(lib);
					registerEventListeners();
					prepareGame();
		
					animate();
                });
            });
		</script>
	</body>
</html>