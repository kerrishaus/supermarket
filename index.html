<!DOCTYPE html>
<html>
	<head>
		<!-- https://html2app.dev/ saved for later -->
		<title>let's go shoppin</title>

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
		
		<link rel='stylesheet' href='./styles/game.css'>
		<link rel='stylesheet' href='./styles/interface.css'>
		
		<script src="https://kerrishaus.com/assets/scripts/jquery-3.6.0.min.js"></script>
		<script src="https://portal.kerrishaus.com/assets/javascript/messages.js"></script>
		<link rel='stylesheet' href='https://portal.kerrishaus.com/assets/styles/messages.css'>
	</head>

	<body>
		<div id='interface' class="gameInterfaceContainer">
			<div class='banner'>
				<div>
					i'm blocked by the fps counter
				</div>
				<div>
					$<span id='money'>0</span>
				</div>
				<div id='reputation'>
					rep <span>0</span>
				</div>
			</div>
			
			<div class='buttons'>
				<div class='upgrades'>
					
				</div>
			</div>
	    </div>

		<script type='module'>
			import AmmoLib from "https://kerrishaus.com/assets/ammojs/ammo.module.js";
			let Ammo;

		    import * as THREE from "https://kerrishaus.com/assets/threejs/build/three.module.js";
		    import { CSS2DObject, CSS2DRenderer } from "https://kerrishaus.com/assets/threejs/examples/jsm/renderers/CSS2DRenderer.js";
		    import { TransformControls } from 'https://kerrishaus.com/assets/threejs/examples/jsm/controls/TransformControls.js';
			import { OrbitControls } from 'https://kerrishaus.com/assets/threejs/examples/jsm/controls/OrbitControls.js';
			import { GLTFLoader } from 'https://kerrishaus.com/assets/threejs/examples/jsm/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'https://kerrishaus.com/assets/threejs/examples/jsm/loaders/DRACOLoader.js';
			import { RoomEnvironment } from 'https://kerrishaus.com/assets/threejs/examples/jsm/environments/RoomEnvironment.js';

			import Stats from 'https://kerrishaus.com/assets/threejs/examples/jsm/libs/stats.module.js';
		    
			import * as GeometryUtil from "./scripts/GeometryUtility.js";

			import { PhysicsScene } from "./scripts/PhysicsScene.js";

			import { PhysicsMesh } from "./scripts/PhysicsMesh.js";
		    import { DynamicMesh } from "./scripts/DynamicMesh.js";

			import { RigidBodyCube } from "./scripts/RigidBodyCube.js";
			import { RigidBodySphere } from "./scripts/RigidBodySphere.js";
			import { KinematicCube } from "./scripts/KinematicCube.js";

		    import { Interactable } from "./scripts/InteractableMesh.js";
			import { Carryable } from "./scripts/Carryable.js";

			import { Shop } from "./scripts/Shop.js";
		    import { Player } from "./scripts/Player.js";
			import { Customer } from "./scripts/Customer.js";
		    import { RecycleBin } from "./scripts/RecycleBin.js";
			import { Tomato } from "./scripts/Tomato.js";
			import { TomatoPlant } from "./scripts/TomatoPlant.js";
			import { TomatoStand } from "./scripts/TomatoStand.js";
			import { BuyableTile } from "./scripts/BuyableTile.js";
		    
		    let renderer, stats, htmlRenderer, scene, camera, freeControls;

			let dracoLoader, loader, mixer;
		    
		    function prepareThree()
		    {
				console.log("Preparing Three.");

		        renderer = new THREE.WebGLRenderer({
		            antialias: true,
		            shadowMap: true
		        });
		        renderer.setSize(window.innerWidth, window.innerHeight);
		        document.body.appendChild(renderer.domElement);

				stats = new Stats();
				document.getElementById('interface').appendChild(stats.dom);
		        
    			htmlRenderer = new CSS2DRenderer();
    			htmlRenderer.setSize(window.innerWidth, window.innerHeight);
    			htmlRenderer.domElement.style.position = 'absolute';
    			htmlRenderer.domElement.style.top = '0px';
    			document.body.appendChild(htmlRenderer.domElement).style.pointerEvents = "none";
		        
		        scene = new PhysicsScene();
		        window.scene = scene; // TODO: FIXME: I don't really feel great about this, but it works, so it stays.
				scene.background = new THREE.Color(0xbfe3dd);

				const pmremGenerator = new THREE.PMREMGenerator(renderer);
				scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
		        
		        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
		        
                window.addEventListener('resize', (event) =>
                {
					camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
					console.log("Window resized.");
                });

				camera.position.z = 10;
				camera.position.y = -12;
				camera.lookAt(new THREE.Vector3(0, 0, 0));
				
				freeControls = new OrbitControls(camera, renderer.domElement);
				freeControls.target.set(0, 0, 0);
				freeControls.update();
				freeControls.enabled = false;

				dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath('https://kerrishaus.com/assets/threejs/examples/js/libs/draco/gltf/');

				loader = new GLTFLoader();
				loader.setDRACOLoader(dracoLoader);
				loader.load( 'models/LittlestTokyo_placeholder.glb', function (gltf)
				{
					const model = gltf.scene;
					//model.position.set(5, 26, 11.45); // for right out front
					model.position.set(5, 30, 11.45);
					model.rotation.x = 1.5708;
					//model.rotation.y = 1.5708;
					model.scale.set(0.06, 0.06, 0.06);
					scene.add(model);

					mixer = new THREE.AnimationMixer(model);
					mixer.clipAction(gltf.animations[0]).play();
				}, undefined, function(e)
				{
					console.error(e);
				} );

				console.log("Three is ready.");
		    }

			window.collisionConfiguration_ = null;
			window.dispatcher_ 			   = null;
			window.broadphase_             = null;
			window.solver_				   = null;
			window.physicsWorld            = null;
			window.physicsBodies 		   = new Array();
			window.tmpTransform 		   = null;

			function prepareAmmo(lib)
			{
				console.log("Preparing Ammo.");

				Ammo = lib;
				window.Ammo = lib;

				collisionConfiguration_ = new Ammo.btDefaultCollisionConfiguration();
				dispatcher_  			= new Ammo.btCollisionDispatcher(collisionConfiguration_);
				broadphase_  			= new Ammo.btDbvtBroadphase();
				solver_      			= new Ammo.btSequentialImpulseConstraintSolver();
				physicsWorld 			= new Ammo.btDiscreteDynamicsWorld(dispatcher_, broadphase_, solver_, collisionConfiguration_);
				physicsWorld.setGravity(new Ammo.btVector3(0, 0, -100));

				tmpTransform = new Ammo.btTransform();

				console.log("Ammo is ready.");
			}

			function registerEventListeners()
			{
				window.oncontextmenu = function(event)
				{
					event.preventDefault();
					event.stopPropagation();
					return false;
				};

				window.addEventListener("mousemove", (event) =>
				{
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					event.preventDefault();
				});
				
				window.addEventListener("touchmove", (event) =>
				{
					mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2 + 1;
					
					event.preventDefault();
				});

				function moveStart(event)
				{
					moving = true;
					scene.add(moveTarget);
				}

				function moveEnd(event)
				{
					moving = false;
					scene.remove(moveTarget);
				}

				window.addEventListener("mousedown",  moveStart, event);
				window.addEventListener("touchstart", moveStart, event);
				window.addEventListener("mouseup",  moveEnd, event);
				window.addEventListener("touchend", moveEnd, event);

				window.addEventListener("keydown", (event) =>
				{
					keys[event.code] = true;

					if (event.code == "KeyO")
					{
						freeCam = !freeCam;
						freeControls.enabled = freeCam;
						console.log("freecam toggled");
					}
				});
				
				window.addEventListener("keyup", (event) =>
				{
					keys[event.code] = false;
				});
			}
		    
		    let shop, player;
		    
            let keys = new Array();
            let moving = false, freeCam = false;
            
            let moveTarget = new THREE.Mesh(new THREE.SphereGeometry(0.25, 24, 8), new THREE.MeshPhongMaterial({ color: 0x00ffff, 
                                                                                                                 flatShading: true,
                                                                                                                 transparent: true,
                                                                                                                 opacity: 0.7,
                                                                                                                }));
            
			let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

            let mouse = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let intersects = new THREE.Vector3();
            
            const clock = new THREE.Clock();

			function prepareGame()
			{
				console.log("Preparing game.");

				shop = new Shop();
				scene.add(shop);

				player = new Player();
				scene.add(player);
	
				console.log("Game is ready.");

				animate();
			}

			function physicsStep(deltaTime)
			{
				physicsWorld.stepSimulation(deltaTime, 10);

				for (const object of physicsBodies)
				{
					object.motionState.getWorldTransform(tmpTransform);

					const pos = tmpTransform.getOrigin();
					const quat = tmpTransform.getRotation();
					const pos3 = new THREE.Vector3(pos.x(), pos.y(), pos.z());
					const quat3 = new THREE.Quaternion(quat.x(), quat.y(), quat.z(), quat.w());
					
					object.position.copy(pos3);
					object.quaternion.copy(quat3);
				}

				detectCollision();
			}

			function detectCollision()
			{
				let dispatcher = physicsWorld.getDispatcher();
				let numManifolds = dispatcher.getNumManifolds();

				for ( let i = 0; i < numManifolds; i ++ )
				{
					let contactManifold = dispatcher.getManifoldByIndexInternal( i );
					let numContacts = contactManifold.getNumContacts();

					for ( let j = 0; j < numContacts; j++ )
					{
						let contactPoint = contactManifold.getContactPoint( j );
						let distance = contactPoint.getDistance();

						if (distance > 0.0)
							continue;

						console.log({manifoldIndex: i, contactIndex: j, distance: distance});
					}
				}
			}
			
			function animate()
			{
				requestAnimationFrame(animate);
				
				const deltaTime = clock.getDelta();

				if (!moving)
				{
					if (keys["KeyW"] || keys["ArrowUp"])
						player.position.y += 0.15;
					if (keys["KeyA"] || keys["ArrowLeft"])
						player.position.x -= 0.15;
					if (keys["KeyS"] || keys["ArrowDown"])
						player.position.y -= 0.15;
					if (keys["KeyD"] || keys["ArrowRight"])
						player.position.x += 0.15;
				}
			    else
			    {
    			    raycaster.setFromCamera(mouse, camera);
                    raycaster.ray.intersectPlane(plane, intersects);
                    moveTarget.position.set(intersects.x, intersects.y, intersects.z);
					
					let y2 = moveTarget.position.y, y1 = player.position.y;
					let x2 = moveTarget.position.x, x1 = player.position.x;
					let angle = Math.atan2( y2 - y1, x2 - x1 ) - 1.5708;
					player.rotation.z = angle;
    			    player.position.lerp(moveTarget.position, 0.03);
					player.position.z = 0.5;
			    }
				
				if (!freeCam)
				{
					camera.position.copy(player.position);
					camera.position.z = 10;
					camera.position.y -= 6;
					camera.lookAt(player.position);
				}

                scene.children.forEach((object) =>
                {
					if ('update' in object)
						object.update(deltaTime);

					if (object instanceof Interactable)
					{
						if (player.box.intersectsBox(object.trigger))
							object.onTrigger(player);
						else if (object.triggeringObjects.includes(player))
							object.onStopTrigger(player);

						for (const customer of shop.customers)
						{
							// customer intersects with interactable's trigger
							if (object.trigger.intersectsBox(customer.box))
							{
								// object is not currently triggered by the customer
								if (!object.triggeringObjects.includes(customer))
									object.onTrigger(customer);
							}
							// customer is not intersecting with this trigger
							else
							{
								// if this trigger is triggered by the customer, stop triggering
								if (object.triggeringObjects.includes(customer))
									object.onStopTrigger(customer);
							}
						}
					}
                });

				//physicsStep(deltaTime);

				if (freeCam)
					freeControls.update();

				stats.update();

				if (mixer)
					mixer.update(deltaTime);
                
				renderer.render(scene, camera);
				htmlRenderer.render(scene, camera);
			};
			
			/*
			if (document.webkitFullscreenElement) 
			{
                document.webkitCancelFullScreen();
            }
            else
            {
                const el = document.documentElement;
                el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
            */

			window.addEventListener('DOMContentLoaded', async () =>
            {
                AmmoLib().then((lib) =>
                {
					prepareThree();
					prepareAmmo(lib);
					registerEventListeners();
					prepareGame();
                });
            });
		</script>
	</body>
</html>